package io.github.kkriske.wrapper.nativeimage;

import io.github.kkriske.wrapper.util.LibraryMetadata;
import org.graalvm.nativeimage.hosted.Feature;
import org.graalvm.nativeimage.hosted.RuntimeForeignAccess;
import org.graalvm.nativeimage.hosted.RuntimeResourceAccess;

import java.io.IOException;
import java.io.InputStream;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.ValueLayout;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

// WIP, no support for native image yet
public class LibraryWrapperFeature implements Feature {

    private final String EXPORT_PATH_PROPERTY = "io.github.kkriske.wrapper.exportPath";

    @Override
    public void duringSetup(DuringSetupAccess access) {
        registerFfiCalls();
    }

    @Override
    public void beforeAnalysis(BeforeAnalysisAccess access) {
        handleLibraryResources();
    }

    private void handleLibraryResources() {
        String libraryName = LibraryMetadata.mappedLibraryName();
        String libraryResource = LibraryMetadata.libraryResource();
        String exportLocation = System.getProperty(EXPORT_PATH_PROPERTY, "");
        if (exportLocation.isEmpty()) {
            // Do not export the library and include it in native-image instead
            RuntimeResourceAccess.addResource(LibraryWrapperFeature.class.getModule(), libraryResource);
        } else {
            // export the required library to the specified path,
            // the user is responsible to make sure the created native-image can actually find it.
            Path targetPath = Paths.get(exportLocation, libraryName);
            try (InputStream in = LibraryWrapperFeature.class.getResourceAsStream(libraryResource)) {
                Files.createDirectories(targetPath.getParent());
                Files.copy(in, targetPath, StandardCopyOption.REPLACE_EXISTING);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Registration of descriptors generated by jextract will be picked up automatically in the future.
     * https://github.com/oracle/graal/issues/8113#issuecomment-2343982644
     */
    private void registerFfiCalls() {
        // graal_create_isolate
        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.of(
                ValueLayout.JAVA_INT,
                ValueLayout.ADDRESS,
                ValueLayout.ADDRESS,
                ValueLayout.ADDRESS
        ));
        // graal_tear_down_isolate
        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.of(
                ValueLayout.JAVA_INT,
                ValueLayout.ADDRESS
        ));
        // add
        RuntimeForeignAccess.registerForDowncall(FunctionDescriptor.of(
                ValueLayout.JAVA_INT,
                ValueLayout.ADDRESS,
                ValueLayout.JAVA_INT,
                ValueLayout.JAVA_INT
        ));
    }
}
